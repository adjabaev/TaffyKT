package be.arby.taffy.compute.grid

import be.arby.taffy.compute.grid.types.GridTrack
import be.arby.taffy.compute.grid.types.TrackCounts
import be.arby.taffy.geometry.extensions.gridAxisSum
import be.arby.taffy.lang.Option
import be.arby.taffy.maths.axis.AbsoluteAxis
import be.arby.taffy.maths.saturatingSub
import be.arby.taffy.resolve.resolveOrZeroOtRlp
import be.arby.taffy.style.Style
import be.arby.taffy.style.dimension.LengthPercentage
import be.arby.taffy.style.grid.GridTrackRepetition
import be.arby.taffy.style.grid.NonRepeatedTrackSizingFunction
import be.arby.taffy.style.grid.TrackSizingFunction
import be.arby.taffy.util.maybeMin
import be.arby.taffy.utils.cycle
import be.arby.taffy.utils.findMap
import kotlin.math.ceil
import kotlin.math.floor
import kotlin.math.max
import kotlin.math.min

class ExplicitGrid {
    companion object {
        fun computeExplicitGridSizeInAxis(style: Style, axis: AbsoluteAxis): Int {
            // Load the grid-template-rows or grid-template-columns definition (depending on the axis)
            val template = style.gridTemplateTracks(axis)

            // If template contains no tracks, then there are trivially zero explcit tracks
            if (template.isEmpty()) {
                return 0
            }

            // If there are any repetitions that contains no tracks, then the whole definition should be considered invalid
            // and we default to no explicit tracks
            val templateHasRepetitionsWithZeroTracks = template.any { trackDef ->
                when (trackDef) {
                    is TrackSizingFunction.Single -> false
                    is TrackSizingFunction.Repeat -> trackDef.l.isEmpty()
                }
            }
            if (templateHasRepetitionsWithZeroTracks) {
                return 0
            }

            // Compute that number of track generated by single track definition and repetitions with a fixed repetition count
            val nonAutoRepeatingTrackCount = template.sumOf { trackDef ->
                when (trackDef) {
                    is TrackSizingFunction.Single -> 1
                    is TrackSizingFunction.Repeat -> {
                        if (trackDef.g is GridTrackRepetition.Count) {
                            (trackDef.g as GridTrackRepetition.Count).i * trackDef.l.size
                        } else {
                            0
                        }
                    }
                }
            }

            val autoRepetitionCount = template.count { trackDef -> trackDef.isAutoRepetition() }
            val nonRepeatingTrackCount = template.size - autoRepetitionCount
            val allTrackDefsHaveFixedComponent = template.all { trackDef ->
                when (trackDef) {
                    is TrackSizingFunction.Single -> trackDef.f.hasFixedComponent()
                    is TrackSizingFunction.Repeat -> trackDef.l.all { f -> f.hasFixedComponent() }
                }
            }

            val templateIsValid =
                autoRepetitionCount == 0 || (autoRepetitionCount == 1 && allTrackDefsHaveFixedComponent)

            // If the template is invalid because it contains multiple auto-repetition definitions or it combines an auto-repetition
            // definition with non-fixed-size track sizing functions, then disregard it entirely and default to zero explicit tracks
            if (!templateIsValid) {
                return 0
            }

            // If there are no repetitions, then the number of explicit tracks is simply equal to the lengths of the track definition
            // vector (as each item in the Vec represents one track).
            if (autoRepetitionCount == 0) {
                return nonAutoRepeatingTrackCount
            }

            val repetitionDefinition: List<NonRepeatedTrackSizingFunction> = template.findMap { def ->
                when (def) {
                    is TrackSizingFunction.Single -> Option.None
                    is TrackSizingFunction.Repeat -> {
                        if (def.g is GridTrackRepetition.Count) {
                            Option.None
                        } else {
                            Option.Some(def.l)
                        }
                    }
                }
            }.unwrap()
            val repetitionTrackCount = repetitionDefinition.size

            // Otherwise, run logic to resolve the auto-repeated track count:
            //
            // If the grid container has a definite size or max size in the relevant axis:
            //   - then the number of repetitions is the largest possible positive integer that does not cause the grid to overflow the content
            //     box of its grid container.
            // Otherwise, if the grid container has a definite min size in the relevant axis:
            //   - then the number of repetitions is the smallest possible positive integer that fulfills that minimum requirement
            // Otherwise, the specified track list repeats only once.
            val styleSize = style.size.getAbs(axis).intoOption()
            val styleMinSize = style.minSize.getAbs(axis).intoOption()
            val styleMaxSize = style.maxSize.getAbs(axis).intoOption()

            val outerContainerSize = styleSize.maybeMin(styleMaxSize).or(styleMaxSize).or(styleMinSize)
            val innerContainerSize = outerContainerSize.map { size ->
                val paddingSum = style.padding.resolveOrZeroOtRlp(outerContainerSize).gridAxisSum(axis)
                val borderSum = style.border.resolveOrZeroOtRlp(outerContainerSize).gridAxisSum(axis)
                size - paddingSum - borderSum
            }
            val sizeIsMaximum = styleSize.isSome() || styleMaxSize.isSome()

            // Determine the number of repetitions
            val numRepetitions: Int = if (innerContainerSize.isNone()) {
                1
            } else {
                val innerContainerSize = innerContainerSize.unwrap()
                val parentSize = Option.Some(innerContainerSize)

                /// ...treating each track as its max track sizing function if that is definite or as its minimum track sizing function
                /// otherwise, flooring the max track sizing function by the min track sizing function if both are definite
                fun trackDefiniteValue(
                    sizingFunction: NonRepeatedTrackSizingFunction,
                    parentSize: Option<Float>,
                ): Float {
                    val maxSize = sizingFunction.max.definiteValue(parentSize)
                    val minSize = sizingFunction.max.definiteValue(parentSize)
                    return maxSize.map { max -> max.maybeMin(minSize) }.orElse { minSize }.unwrap()
                }

                val nonRepeatingTrackUsedSpace = template
                    .map { trackDef ->
                        when (trackDef) {
                            is TrackSizingFunction.Single -> {
                                trackDefiniteValue(trackDef.f, parentSize)
                            }

                            is TrackSizingFunction.Repeat -> if (trackDef.g is GridTrackRepetition.Count) {
                                val sum =
                                    trackDef.l.map { sizingFunction -> trackDefiniteValue(sizingFunction, parentSize) }
                                        .sum()
                                sum * (trackDef.g as GridTrackRepetition.Count).i.toFloat()
                            } else {
                                0f
                            }
                        }
                    }
                    .sum()
                val gapSize = style.gap.getAbs(axis).resolveOrZero(Option.Some(innerContainerSize))

                // Compute the amount of space that a single repetition of the repeated track list takes
                val perRepetitionTrackUsedSpace = repetitionDefinition
                    .map { sizingFunction -> trackDefiniteValue(sizingFunction, parentSize) }
                    .sum()

                // We special case the first repetition here because the number of gaps in the first repetition
                // depends on the number of non-repeating tracks in the template
                val firstRepetitionAndNonRepeatingTracksUsedSpace =
                    nonRepeatingTrackUsedSpace + perRepetitionTrackUsedSpace +
                            ((nonAutoRepeatingTrackCount + repetitionTrackCount).saturatingSub(1) * gapSize)

                // If a single repetition already overflows the container then we return 1 as the repetition count
                // (the number of repetitions is floored at 1)
                if (firstRepetitionAndNonRepeatingTracksUsedSpace > innerContainerSize) {
                    1
                } else {
                    val perRepetitionGapUsedSpace = (repetitionDefinition.size.toFloat()) * gapSize
                    val perRepetitionUsedSpace = perRepetitionTrackUsedSpace + perRepetitionGapUsedSpace
                    val numRepetitionThatFit =
                        (innerContainerSize - firstRepetitionAndNonRepeatingTracksUsedSpace) / perRepetitionUsedSpace

                    // If the container size is a preferred or maximum size:
                    //   Then we return the maximum number of repetitions that fit into the container without overflowing.
                    // If the container size is a minimum size:
                    //   - Then we return the minimum number of repititions required to overflow the size.
                    //
                    // In all cases we add the additional repetition that was already accounted for in the special-case computation above
                    if (sizeIsMaximum) {
                        floor(numRepetitionThatFit).toInt() + 1
                    } else {
                        ceil(numRepetitionThatFit).toInt() + 1
                    }
                }
            }

            return nonAutoRepeatingTrackCount + (repetitionTrackCount * numRepetitions)
        }

        fun initializeGridTracks(
            tracks: ArrayList<GridTrack>,
            counts: TrackCounts,
            trackTemplate: List<TrackSizingFunction>,
            autoTracks: List<NonRepeatedTrackSizingFunction>,
            gap: LengthPercentage,
            trackHasItems: (Int) -> Boolean,
        ) {
            // Clear vector (in case this is a re-layout), reserve space for all tracks ahead of time to reduce allocations,
            // and push the initial gutter
            tracks.clear()
            tracks.add(GridTrack.gutter(gap))

            // Create negative implicit tracks
            if (autoTracks.isEmpty()) {
                val iter = generateSequence { NonRepeatedTrackSizingFunction.AUTO }
                createImplicitTracks(tracks, counts.negativeImplicit, iter.iterator(), gap)
            } else {
                val maxCount = max(autoTracks.size, counts.negativeImplicit)
                val minCount = min(autoTracks.size, counts.negativeImplicit)
                val offset = maxCount % minCount
                val iter = autoTracks.asSequence().cycle().drop(offset)
                createImplicitTracks(tracks, counts.negativeImplicit, iter.iterator(), gap)
            }

            var currentTrackIndex = counts.negativeImplicit

            // Create explicit tracks
            // An explicit check against the count (rather than just relying on track_template being empty) is required here
            // because a count of zero can result from the track_template being invalid, in which case it should be ignored.
            if (counts.explicit > 0) {
                trackTemplate.forEach { trackSizingFunction ->
                    when (trackSizingFunction) {
                        is TrackSizingFunction.Single -> {
                            tracks.add(
                                GridTrack.make(
                                    trackSizingFunction.f.minSizingFunction(),
                                    trackSizingFunction.f.maxSizingFunction()
                                )
                            )
                            tracks.add(GridTrack.gutter(gap))
                            currentTrackIndex += 1
                        }

                        is TrackSizingFunction.Repeat -> {
                            if (trackSizingFunction.g is GridTrackRepetition.Count) {
                                val trackIter = trackSizingFunction.l.asSequence().cycle()
                                    .take(trackSizingFunction.l.size * (trackSizingFunction.g as GridTrackRepetition.Count).i)
                                trackIter.forEach { sizingFunction ->
                                    tracks.add(
                                        GridTrack
                                            .make(
                                                sizingFunction.minSizingFunction(),
                                                sizingFunction.maxSizingFunction()
                                            )
                                    )
                                    tracks.add(GridTrack.gutter(gap))
                                    currentTrackIndex += 1
                                }
                            } else {
                                val autoRepeatedTrackCount = (counts.explicit - (trackTemplate.size - 1))
                                val iter = trackSizingFunction.l.asSequence().cycle()
                                for (trackDef in iter.take(autoRepeatedTrackCount)) {
                                    val track =
                                        GridTrack.make(trackDef.minSizingFunction(), trackDef.maxSizingFunction())
                                    val gutter = GridTrack.gutter(gap)

                                    // Auto-fit tracks that don't contain should be collapsed.
                                    if (trackSizingFunction.g is GridTrackRepetition.AutoFit && !trackHasItems(
                                            currentTrackIndex
                                        )
                                    ) {
                                        track.collapse()
                                        gutter.collapse()
                                    }

                                    tracks.add(track)
                                    tracks.add(gutter)

                                    currentTrackIndex += 1
                                }
                            }
                        }
                    }
                }
            }

            // Create positive implicit tracks
            if (autoTracks.isEmpty()) {
                val iter = generateSequence { NonRepeatedTrackSizingFunction.AUTO }
                createImplicitTracks(tracks, counts.positiveImplicit, iter.iterator(), gap)
            } else {
                val iter = autoTracks.asSequence().cycle()
                createImplicitTracks(tracks, counts.positiveImplicit, iter.iterator(), gap)
            }

            // Mark first and last grid lines as collapsed
            tracks.first().collapse()
            tracks.last().collapse()
        }

        fun createImplicitTracks(
            tracks: ArrayList<GridTrack>,
            count: Int,
            autoTracksIter: Iterator<NonRepeatedTrackSizingFunction>,
            gap: LengthPercentage,
        ) {
            for (ix in 0 until count) {
                val trackDef = autoTracksIter.next()
                tracks.add(GridTrack.make(trackDef.minSizingFunction(), trackDef.maxSizingFunction()))
                tracks.add(GridTrack.gutter(gap))
            }
        }
    }
}
