package be.arby.taffy.compute.grid

import be.arby.taffy.compute.grid.types.GridTrack
import be.arby.taffy.compute.grid.types.TrackCounts
import be.arby.taffy.geom.AbsoluteAxis
import be.arby.taffy.geom.Size
import be.arby.taffy.lang.Option
import be.arby.taffy.lang.collections.*
import be.arby.taffy.maths.saturatingSub
import be.arby.taffy.style.dimension.LengthPercentage
import be.arby.taffy.style.grid.GridContainerStyle
import be.arby.taffy.style.grid.GridTrackRepetition
import be.arby.taffy.style.grid.NonRepeatedTrackSizingFunction
import be.arby.taffy.style.grid.TrackSizingFunction
import be.arby.taffy.util.maybeMin
import kotlin.math.ceil
import kotlin.math.floor

/// ...treating each track as its max track sizing function if that is definite or as its minimum track sizing function
/// otherwise, flooring the max track sizing function by the min track sizing function if both are definite
private fun trackDefiniteValue(sizingFunction: NonRepeatedTrackSizingFunction, parentSize: Option<Float>): Float {
    val maxSize = sizingFunction.max.definiteValue(parentSize)
    val minSize = sizingFunction.min.definiteValue(parentSize)
    return maxSize.map { max -> max.maybeMin(minSize) }.or(minSize).unwrap()
}

/**
 * Compute the number of rows and columns in the explicit grid
 */
fun computeExplicitGridSizeInAxis(
    style: GridContainerStyle,
    template: MutableList<TrackSizingFunction>,
    innerContainerSize: Size<Option<Float>>,
    axis: AbsoluteAxis,
): Int {
    // If template contains no tracks, then there are trivially zero explicit tracks
    if (template.isEmpty()) {
        return 0;
    }

    // If there are any repetitions that contains no tracks, then the whole definition should be considered invalid
    // and we default to no explicit tracks
    val templateHasRepetitionsWithZeroTracks = template.any { trackDef ->
        when (trackDef) {
            is TrackSizingFunction.Single -> false
            is TrackSizingFunction.Repeat -> trackDef.l.isEmpty()
        }
    }

    if (templateHasRepetitionsWithZeroTracks) {
        return 0;
    }

    // Compute that number of track generated by single track definition and repetitions with a fixed repetition count
    val nonAutoRepeatingTrackCount = template
        .map { trackDef ->
            if (trackDef is TrackSizingFunction.Single) {
                1
            } else if (trackDef is TrackSizingFunction.Repeat && trackDef.g is GridTrackRepetition.Count) {
                (trackDef.g as GridTrackRepetition.Count).i * trackDef.l.size
            } else {
                0
            }
        }
        .sum()

    val autoRepetitionCount = template.filter { trackDef -> trackDef.isAutoRepetition() }.count()
    val allTrackDefsHaveFixedComponent = template.all { trackDef ->
        when (trackDef) {
            is TrackSizingFunction.Single -> trackDef.f.hasFixedComponent()
            is TrackSizingFunction.Repeat -> {
                trackDef.l.all { sizingFunction -> sizingFunction.hasFixedComponent() }
            }
        }
    }

    val templateIsValid =
        autoRepetitionCount == 0 || (autoRepetitionCount == 1 && allTrackDefsHaveFixedComponent)

    // If the template is invalid because it contains multiple auto-repetition definitions or it combines an auto-repetition
    // definition with non-fixed-size track sizing functions, then disregard it entirely and default to zero explicit tracks
    if (!templateIsValid) {
        return 0;
    }

    // If there are no repetitions, then the number of explicit tracks is simply equal to the lengths of the track definition
    // vector (as each item in the Vec represents one track).
    if (autoRepetitionCount == 0) {
        return nonAutoRepeatingTrackCount;
    }

    val repetitionDefinition = template
        .findMap { def ->
            if (def is TrackSizingFunction.Repeat) {
                when (def.g) {
                    is GridTrackRepetition.Count -> Option.None
                    else -> Option.Some(def.l)
                }
            } else {
                Option.None
            }
        }
        .unwrap()
    val repetitionTrackCount = repetitionDefinition.len();

    // Otherwise, run logic to resolve the auto-repeated track count:
    //
    // If the grid container has a definite size or max size in the relevant axis:
    //   - then the number of repetitions is the largest possible positive integer that does not cause the grid to overflow the content
    //     box of its grid container.
    // Otherwise, if the grid container has a definite min size in the relevant axis:
    //   - then the number of repetitions is the smallest possible positive integer that fulfills that minimum requirement
    // Otherwise, the specified track list repeats only once.
    val sizeIsMaximum =
        style.size().getAbs(axis).intoOption().isSome() || style.maxSize().getAbs(axis).intoOption().isSome();

    // Determine the number of repetitions
    val numRepetitions = when (val v = innerContainerSize.getAbs(axis)) {
        is Option.None -> 1
        is Option.Some -> {
            val parentSize = Option.Some(v.unwrap())

            val nonRepeatingTrackUsedSpace = template
                .map { trackDef ->
                    if (trackDef is TrackSizingFunction.Single) {
                        trackDefiniteValue(trackDef.f, parentSize)
                    } else if (trackDef is TrackSizingFunction.Repeat && trackDef.g is GridTrackRepetition.Count) {
                        val sum = trackDef.l
                            .map { sizingFunction -> trackDefiniteValue(sizingFunction, parentSize) }
                            .sum()
                        sum * (trackDef.g as GridTrackRepetition.Count).i
                    } else {
                        0f
                    }
                }
                .sum();
            val gapSize = style.gap().getAbs(axis).resolveOrZero(Option.Some(v.unwrap()));

            // Compute the amount of space that a single repetition of the repeated track list takes
            val perRepetitionTrackUsedSpace = repetitionDefinition
                .map { sizingFunction -> trackDefiniteValue(sizingFunction, parentSize) }
                .sum()

            // We special case the first repetition here because the number of gaps in the first repetition
            // depends on the number of non-repeating tracks in the template
            val firstRepetitionAndNonRepeatingTracksUsedSpace = nonRepeatingTrackUsedSpace +
                    perRepetitionTrackUsedSpace +
                    ((nonAutoRepeatingTrackCount + repetitionTrackCount).saturatingSub(1).toFloat() * gapSize);

            // If a single repetition already overflows the container then we return 1 as the repetition count
            // (the number of repetitions is floored at 1)
            if (firstRepetitionAndNonRepeatingTracksUsedSpace > v.unwrap()) {
                1
            } else {
                val perRepetitionGapUsedSpace = repetitionDefinition.len().toFloat() * gapSize;
                val perRepetitionUsedSpace = perRepetitionTrackUsedSpace + perRepetitionGapUsedSpace;
                val numRepetitionThatFit =
                    (v.unwrap() - firstRepetitionAndNonRepeatingTracksUsedSpace) / perRepetitionUsedSpace;

                // If the container size is a preferred or maximum size:
                //   Then we return the maximum number of repetitions that fit into the container without overflowing.
                // If the container size is a minimum size:
                //   - Then we return the minimum number of repetitions required to overflow the size.
                //
                // In all cases we add the additional repetition that was already accounted for in the special-case computation above
                if (sizeIsMaximum) {
                    floor(numRepetitionThatFit).toInt() + 1
                } else {
                    ceil(numRepetitionThatFit).toInt() + 1
                }
            }
        }
    }

    return nonAutoRepeatingTrackCount + (repetitionTrackCount * numRepetitions)
}

/**
 * Resolve the track sizing functions of explicit tracks, automatically created tracks, and gutters
 * given a set of track counts and all of the relevant styles
 */
fun initializeGridTracks(
    tracks: MutableList<GridTrack>,
    counts: TrackCounts,
    trackTemplate: MutableList<TrackSizingFunction>,
    autoTracks: MutableList<NonRepeatedTrackSizingFunction>,
    gap: LengthPercentage,
    trackHasItems: (Int) -> Boolean,
) {
    // Clear vector (in case this is a re-layout), reserve space for all tracks ahead of time to reduce allocations,
    // and push the initial gutter
    tracks.clear();
    tracks.add(GridTrack.gutter(gap))

    // Create negative implicit tracks
    if (counts.negativeImplicit > 0) {
        if (autoTracks.isEmpty()) {
            val iter = repeatElement(NonRepeatedTrackSizingFunction.AUTO)
            createImplicitTracks(tracks, counts.negativeImplicit, iter, gap)
        } else {
            val offset = autoTracks.len() - (counts.negativeImplicit % autoTracks.len());
            val iter = autoTracks.copied().cycle().skip(offset);
            createImplicitTracks(tracks, counts.negativeImplicit, iter, gap)
        }
    }

    var currentTrackIndex = (counts.negativeImplicit)

    // Create explicit tracks
    // An explicit check against the count (rather than just relying on track_template being empty) is required here
    // because a count of zero can result from the track_template being invalid, in which case it should be ignored.
    if (counts.explicit > 0) {
        trackTemplate.forEach { trackSizingFunction ->
            if (trackSizingFunction is TrackSizingFunction.Single) {
                tracks.add(
                    GridTrack.new(
                        trackSizingFunction.f.minSizingFunction(),
                        trackSizingFunction.f.maxSizingFunction(),
                    )
                );
                tracks.add(GridTrack.gutter(gap))
                currentTrackIndex += 1
            } else if (trackSizingFunction is TrackSizingFunction.Repeat && trackSizingFunction.g is GridTrackRepetition.Count) {
                val track = trackSizingFunction.l.cycle()
                    .take(trackSizingFunction.l.len() * (trackSizingFunction.g as GridTrackRepetition.Count).i)
                track.forEach { sizingFunction: NonRepeatedTrackSizingFunction ->
                    tracks.add(
                        GridTrack.new(
                            sizingFunction.minSizingFunction(),
                            sizingFunction.maxSizingFunction()
                        )
                    )
                    tracks.add(GridTrack.gutter(gap))
                    currentTrackIndex += 1
                }
            } else if (trackSizingFunction is TrackSizingFunction.Repeat) {
                val autoRepeatedTrackCount = counts.explicit - (trackTemplate.len() - 1)
                val iter = trackSizingFunction.l.copied().cycle()
                for (trackDef in iter.take(autoRepeatedTrackCount)) {
                    var track = GridTrack.new(trackDef.minSizingFunction(), trackDef.maxSizingFunction());
                    var gutter = GridTrack.gutter(gap);

                    // Auto-fit tracks that don't contain should be collapsed.
                    if (trackSizingFunction.g is GridTrackRepetition.AutoFit && !trackHasItems(currentTrackIndex)) {
                        track.collapse();
                        gutter.collapse();
                    }

                    tracks.add(track);
                    tracks.add(gutter);

                    currentTrackIndex += 1;
                }
            }
        }
    }

    // Create positive implicit tracks
    if (autoTracks.isEmpty()) {
        val iter = repeatElement(NonRepeatedTrackSizingFunction.AUTO)
        createImplicitTracks(tracks, counts.positiveImplicit, iter, gap)
    } else {
        val iter = autoTracks.copied().cycle();
        createImplicitTracks(tracks, counts.positiveImplicit, iter, gap)
    }

    // Mark first and last grid lines as collapsed
    tracks.first().collapse()
    tracks.last().collapse()
}

/**
 * Utility function for repeating logic of creating implicit tracks
 */
fun createImplicitTracks(
    tracks: MutableList<GridTrack>,
    count: Int,
    autoTracksIter: Sequence<NonRepeatedTrackSizingFunction>,
    gap: LengthPercentage
) {
    for (a in 0 until count) {
        val trackDef = autoTracksIter.next().unwrap()
        tracks.add(GridTrack.new(trackDef.minSizingFunction(), trackDef.maxSizingFunction()))
        tracks.add(GridTrack.gutter(gap))
    }
}
